[
["index.html", "Spatial data analysis Chapter 1 Introduction", " Spatial data analysis Saif Shabou Chapter 1 Introduction This book is based on this tutorial: https://rspatial.org/raster/index.html "],
["data-exploration.html", "Chapter 2 Data exploration 2.1 Get remote sensing data 2.2 Data visualization 2.3 Subset and rename bands 2.4 Spectral profiles", " Chapter 2 Data exploration 2.1 Get remote sensing data # dir.create(&#39;data&#39;, showWarnings = FALSE) # # if (!file.exists(&#39;data/rs/samples.rds&#39;)) { # download.file(&#39;https://biogeo.ucdavis.edu/data/rspatial/rsdata.zip&#39;, dest = &#39;data/rsdata.zip&#39;) # unzip(&#39;data/rsdata.zip&#39;, exdir=&#39;data&#39;) # } 2.2 Data visualization library(raster) ## Loading required package: sp library(rgdal) ## rgdal: version: 1.4-8, (SVN revision 845) ## Geospatial Data Abstraction Library extensions to R successfully loaded ## Loaded GDAL runtime: GDAL 2.2.3, released 2017/11/20 ## Path to GDAL shared files: C:/Users/saif/Documents/R/win-library/3.6/rgdal/gdal ## GDAL binary built with GEOS: TRUE ## Loaded PROJ.4 runtime: Rel. 4.9.3, 15 August 2016, [PJ_VERSION: 493] ## Path to PROJ.4 shared files: C:/Users/saif/Documents/R/win-library/3.6/rgdal/proj ## Linking to sp version: 1.4-1 # Blue b2 &lt;- raster(&#39;data/rs/LC08_044034_20170614_B2.tif&#39;) # Green b3 &lt;- raster(&#39;data/rs/LC08_044034_20170614_B3.tif&#39;) # Red b4 &lt;- raster(&#39;data/rs/LC08_044034_20170614_B4.tif&#39;) # Near Infrared (NIR) b5 &lt;- raster(&#39;data/rs/LC08_044034_20170614_B5.tif&#39;) # Single band and composite maps # You can plot individual layers of a RasterStack of a multi-spectral image. par(mfrow = c(2,2)) plot(b2, main = &quot;Blue&quot;, col = gray(0:100 / 100)) plot(b3, main = &quot;Green&quot;, col = gray(0:100 / 100)) plot(b4, main = &quot;Red&quot;, col = gray(0:100 / 100)) plot(b5, main = &quot;NIR&quot;, col = gray(0:100 / 100)) To make a true (natural) color image that looks like a normal photograph (vegetation in green, water in blue…). The true-color reveals much about landscape than gray images. landsatRGB &lt;- stack(b4, b3, b2) plotRGB(landsatRGB, axes = TRUE, stretch = &quot;lin&quot;, main = &quot;Landsat True Color Composite&quot;) Anoher popular image visualization method in remote sensing is known as “False color” image. This representation makes it easy to see the vegetaion (in red). par(mfrow = c(1,2)) plotRGB(landsatRGB, axes = TRUE, stretch = &quot;lin&quot;, main = &quot;Landsat True Color Composite&quot;) landsatFCC = stack(b5,b4,b3) plotRGB(landsatFCC, axes = TRUE, stretch = &quot;lin&quot;, main = &quot;Landsat False Color Composite&quot;) 2.3 Subset and rename bands 2.3.1 load all the layers We can create a RasterStack withh the 11 layers. These layers represent reflection intensity in the following wavelengths: Ultra Blue, Blue, Green, Red, Near Infrared (NIR), Shortwave Infrared (SWIR) 1, Shortwave Infrared (SWIR) 2, Panachromatic, Cirrus, Thermal Infrared (TIRS) 1, Thermal Infrared (TIRS) 2. filenames &lt;- paste0(&#39;data/rs/LC08_044034_20170614_B&#39;, 1:11, &quot;.tif&quot;) filenames ## [1] &quot;data/rs/LC08_044034_20170614_B1.tif&quot; ## [2] &quot;data/rs/LC08_044034_20170614_B2.tif&quot; ## [3] &quot;data/rs/LC08_044034_20170614_B3.tif&quot; ## [4] &quot;data/rs/LC08_044034_20170614_B4.tif&quot; ## [5] &quot;data/rs/LC08_044034_20170614_B5.tif&quot; ## [6] &quot;data/rs/LC08_044034_20170614_B6.tif&quot; ## [7] &quot;data/rs/LC08_044034_20170614_B7.tif&quot; ## [8] &quot;data/rs/LC08_044034_20170614_B8.tif&quot; ## [9] &quot;data/rs/LC08_044034_20170614_B9.tif&quot; ## [10] &quot;data/rs/LC08_044034_20170614_B10.tif&quot; ## [11] &quot;data/rs/LC08_044034_20170614_B11.tif&quot; landsat &lt;- stack(filenames) landsat ## class : RasterStack ## dimensions : 1245, 1497, 1863765, 11 (nrow, ncol, ncell, nlayers) ## resolution : 30, 30 (x, y) ## extent : 594090, 639000, 4190190, 4227540 (xmin, xmax, ymin, ymax) ## crs : +proj=utm +zone=10 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 ## names : LC08_044034_20170614_B1, LC08_044034_20170614_B2, LC08_044034_20170614_B3, LC08_044034_20170614_B4, LC08_044034_20170614_B5, LC08_044034_20170614_B6, LC08_044034_20170614_B7, LC08_044034_20170614_B8, LC08_044034_20170614_B9, LC08_044034_20170614_B10, LC08_044034_20170614_B11 ## min values : 9.641791e-02, 7.483990e-02, 4.259216e-02, 2.084067e-02, 8.457669e-04, -7.872183e-03, -5.052945e-03, 3.931751e-02, -4.337332e-04, 2.897978e+02, 2.885000e+02 ## max values : 0.73462820, 0.71775615, 0.69246972, 0.78617686, 1.01243150, 1.04320455, 1.11793602, 0.82673049, 0.03547901, 322.43139648, 317.99530029 We can select specific layers (bands) # select first 7 bands only nlayers(landsat) ## [1] 11 landsat &lt;- subset(landsat, 1:7) nlayers(landsat) ## [1] 7 For clarity, we can set the names of the bands names(landsat) ## [1] &quot;LC08_044034_20170614_B1&quot; &quot;LC08_044034_20170614_B2&quot; ## [3] &quot;LC08_044034_20170614_B3&quot; &quot;LC08_044034_20170614_B4&quot; ## [5] &quot;LC08_044034_20170614_B5&quot; &quot;LC08_044034_20170614_B6&quot; ## [7] &quot;LC08_044034_20170614_B7&quot; names(landsat) &lt;- c(&#39;ultra-blue&#39;, &#39;blue&#39;, &#39;green&#39;, &#39;red&#39;, &#39;NIR&#39;, &#39;SWIR1&#39;, &#39;SWIR2&#39;) names(landsat) ## [1] &quot;ultra.blue&quot; &quot;blue&quot; &quot;green&quot; &quot;red&quot; &quot;NIR&quot; ## [6] &quot;SWIR1&quot; &quot;SWIR2&quot; 2.3.2 Spatial subset We can use spatial subsetting in order to limit the analysis to a geographical region. We can specify the extent coordinates similar to the example above and we can use interactive selection from the image with “drawExtent” and “drawPoly” functions. # Using extent extent(landsat) ## class : Extent ## xmin : 594090 ## xmax : 639000 ## ymin : 4190190 ## ymax : 4227540 e &lt;- extent(610000, 4200000, 630000,4220000) # crop landsat by the extent landsatcrop &lt;- crop(landsat, e) # plot par(mfrow = c(1,2)) plot(landsat[[5]]) rect(e[1],e[2],e[3],e[4], border=&#39;red&#39;, lwd=2) plot(landsatcrop[[5]]) The subbset image can be saved with “writeRaster” function # x &lt;- writeRaster(landsatcrop, filename=&quot;cropped-landsat.tif&quot;, overwrite=TRUE) 2.4 Spectral profiles The spectral profile is a plot of the spectrum for pixels representing a certain earth surface features. It demonstrates the difference in spectral properties of various earth surface features. To do that, we need to join information about the lad use and land cover with pixel values of the raster data. # load the polygons with land use land cover information samp &lt;- readRDS(&#39;data/rs/samples.rds&#39;) # generate 300 point samples from the polygons ptsamp &lt;- spsample(samp, 300, type=&#39;regular&#39;) # add the land cover class to the points ptsamp$class &lt;- over(ptsamp, samp)$class # extract values with points df &lt;- extract(landsat, ptsamp) # To see some of the reflectance values head(df) ## ultra.blue blue green red NIR SWIR1 SWIR2 ## [1,] 0.1348463 0.1171285 0.10090701 0.10077689 0.1620628 0.2171030 0.1806697 ## [2,] 0.1325042 0.1150899 0.09971425 0.09843475 0.1831637 0.2129608 0.1747276 ## [3,] 0.1334800 0.1288825 0.13744865 0.18316367 0.3254918 0.3292869 0.1989731 ## [4,] 0.1443883 0.1468389 0.16507718 0.22690523 0.3690165 0.3911583 0.2422809 ## [5,] 0.1321572 0.1143743 0.09774078 0.09529021 0.1667254 0.2016405 0.1645567 ## [6,] 0.1372752 0.1200344 0.10405154 0.10411660 0.1676145 0.2153030 0.1779589 # plot plot(landsat[[5]]) plot(samp, add = TRUE, border = &#39;red&#39;, lwd = 2) plot(ptsamp, pch = 21, bg = &quot;black&quot;, col=&quot;black&quot;, cex = 0.45, add = TRUE) Now, we can compute he mean reflectance values for each class and each band ms &lt;- aggregate(df, list(ptsamp$class), mean) # instead of the first column, we use row names rownames(ms) &lt;- ms[,1] ms &lt;- ms[,-1] ms ## ultra.blue blue green red NIR SWIR1 ## built 0.1770095 0.16882171 0.16839923 0.18151631 0.23660067 0.23342241 ## cropland 0.1122196 0.08998683 0.08391113 0.05331576 0.46224299 0.15512451 ## fallow 0.1325273 0.11680835 0.10406427 0.11311789 0.17682463 0.23101104 ## open 0.1392278 0.13822205 0.15368719 0.20788541 0.34339042 0.35489589 ## water 0.1340949 0.11714744 0.09997358 0.07941412 0.04923834 0.03382958 ## SWIR2 ## built 0.19172661 ## cropland 0.07002481 ## fallow 0.19389564 ## open 0.21224384 ## water 0.02742395 Now we plot the mean spectra of these features. # Create a vector of color for the land cover classes for use in plotting mycolor &lt;- c(&#39;darkred&#39;, &#39;yellow&#39;, &#39;burlywood&#39;, &#39;cyan&#39;, &#39;blue&#39;) #transform ms from a data.frame to a matrix ms &lt;- as.matrix(ms) # First create an empty plot plot(0, ylim=c(0,0.6), xlim = c(1,7), type=&#39;n&#39;, xlab=&quot;Bands&quot;, ylab = &quot;Reflectance&quot;) # add the different classes for (i in 1:nrow(ms)){ lines(ms[i,], type = &quot;l&quot;, lwd = 3, lty = 1, col = mycolor[i]) } # Title title(main=&quot;Spectral Profile from Landsat&quot;, font.main = 2) # Legend legend(&quot;topleft&quot;, rownames(ms), cex=0.8, col=mycolor, lty = 1, lwd =3, bty = &quot;n&quot;) The spectral profile shows differences in the reflectance of different eatures of the earth’s surface. Water shows relatively low reflection in all wavelengths and built surfaces have relatively high reflectance in the longer wavelength. "],
["computation-of-indicators.html", "Chapter 3 Computation of indicators 3.1 NDVI Index 3.2 Principal Component Analysis", " Chapter 3 Computation of indicators 3.1 NDVI Index We can perform some mathematical operations over grid cells. One of the most famous index used in Remote Sensing Image Analysis, is the Normalized Difference Vegetation Index # let&#39;s define the function to compute ndvi index vi &lt;- function(img, k, i) { bk &lt;- img[[k]] bi &lt;- img[[i]] vi &lt;- (bk - bi) / (bk + bi) return(vi) } # plot ndvi &lt;- vi(landsat, 5, 4) plot(ndvi, col = rev(terrain.colors(10)), main = &quot;Landsat-NDVI&quot;) # view histogram of data hist(ndvi, main = &quot;Distribution of NDVI values&quot;, xlab = &quot;NDVI&quot;, ylab= &quot;Frequency&quot;, col = &quot;green&quot;, xlim = c(-0.5, 1), breaks = 30, xaxt = &#39;n&#39;) axis(side=1, at = seq(-0.5,1, 0.05), labels = seq(-0.5,1, 0.05)) In order to identify better the areas with vegetation, we can reclassify differently the values. vegc &lt;- reclassify(ndvi, c(-Inf,0.25,1, 0.25,0.3,2, 0.3,0.4,3, 0.4,0.5,4, 0.5,Inf, 5)) plot(vegc,col = rev(terrain.colors(4)), main = &#39;NDVI based thresholding&#39;) 3.2 Principal Component Analysis Multi-spectral data are sometimes transformed to helps to reduce the dimensionality and noise in the data. The principal components transform is a generic data reduction method that can be used to create a few uncorrelated bands from a larger set of correlated bands. You can calculate the same number of principal components as the number of input bands. The first principal component (PC) explains the largest percentage of variance and other PCs explain additional the variance in decreasing order. # Take a random sample from the cell values set.seed(1) sr &lt;- sampleRandom(landsat, 10000) # perform PCA to the resulting matrix pca &lt;- prcomp(sr, scale = TRUE) screeplot(pca) The first principal component highlights the boundaries between land use classes or spatial details, which is the most common information among all wavelengths. pci &lt;- predict(landsat, pca, index = 1:2) pc2 &lt;- reclassify(pci[[2]], c(-Inf,0,1,0,Inf,NA)) par(mfrow = c(1,2)) plotRGB(landsatFCC, r = 1, g = 2, b = 3, axes = TRUE, stretch = &quot;lin&quot;, main = &quot;Landsat False Color Composite&quot;) plotRGB(landsatFCC, r = 1, g = 2, b = 3, axes = TRUE, stretch = &quot;lin&quot;, main = &quot;Landsat False Color Composite&quot;) plot(pc2, legend = FALSE, add = TRUE) "],
["clustering.html", "Chapter 4 Clustering", " Chapter 4 Clustering For this example, we will follow the National Land Cover Database 2011 (NLCD 2011) classification scheme for a subset of the Central Valley regions. We use cloud-free composite image from Landsat 5 with 6 bands landsat5 &lt;- stack(&#39;data/rs/centralvalley-2011LT5.tif&#39;) names(landsat5) &lt;- c(&#39;blue&#39;, &#39;green&#39;, &#39;red&#39;, &#39;NIR&#39;, &#39;SWIR1&#39;, &#39;SWIR2&#39;) We will use the k-means algorithm to group pixels with similar spectral characteristics. We perform the unsupervised clsutering on a subset of the ndvi layer. # first we compute the ndvi layer ndvi &lt;- (landsat5[[&#39;NIR&#39;]] - landsat5[[&#39;red&#39;]]) / (landsat5[[&#39;NIR&#39;]] + landsat5[[&#39;red&#39;]]) Then we get raster values from a spatial subset of the ndvi layer # Extent to crop ndvi layer e &lt;- extent(-121.807, -121.725, 38.004, 38.072) # crop landsat by the extent ndvi &lt;- crop(ndvi, e) ndvi ## class : RasterLayer ## dimensions : 252, 304, 76608 (nrow, ncol, ncell) ## resolution : 0.0002694946, 0.0002694946 (x, y) ## extent : -121.807, -121.725, 38.00413, 38.07204 (xmin, xmax, ymin, ymax) ## crs : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## source : memory ## names : layer ## values : -0.3360085, 0.7756007 (min, max) # convert the raster to vecor/matrix nr &lt;- getValues(ndvi) str(nr) ## num [1:76608] 0.245 0.236 0.272 0.277 0.277 ... Now we perform the kmeans clustering on the matrix and inspect the output # It is important to set the seed generator because `kmeans` initiates the centers in random locations set.seed(99) # We want to create 10 clusters, allow 500 iterations, start with 5 random sets using &quot;Lloyd&quot; method kmncluster &lt;- kmeans(na.omit(nr), centers = 10, iter.max = 500, nstart = 5, algorithm=&quot;Lloyd&quot;) # kmeans returns an object of class &quot;kmeans&quot; str(kmncluster) ## List of 9 ## $ cluster : int [1:76608] 4 4 3 3 3 3 3 4 4 4 ... ## $ centers : num [1:10, 1] 0.55425 0.00498 0.29997 0.20892 -0.20902 ... ## ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. ..$ : chr [1:10] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## .. ..$ : NULL ## $ totss : num 6459 ## $ withinss : num [1:10] 5.69 6.13 4.91 4.9 5.75 ... ## $ tot.withinss: num 55.8 ## $ betweenss : num 6403 ## $ size : int [1:10] 8932 4550 7156 6807 11672 8624 8736 5040 9893 5198 ## $ iter : int 108 ## $ ifault : NULL ## - attr(*, &quot;class&quot;)= chr &quot;kmeans&quot; Kmeans returns an object of 9 elements. The cell values of kmncluster$cluster range between 1 to 10 corresponding to the input number of cluster we provided. It indicates the cluster label for corresponding pixel. We need to convert theses labels to RasterLayer of the same dimension of the ndvi. # Use the ndvi object to set the cluster values to a new raster knr &lt;- setValues(ndvi, kmncluster$cluster) knr ## class : RasterLayer ## dimensions : 252, 304, 76608 (nrow, ncol, ncell) ## resolution : 0.0002694946, 0.0002694946 (x, y) ## extent : -121.807, -121.725, 38.00413, 38.07204 (xmin, xmax, ymin, ymax) ## crs : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## source : memory ## names : layer ## values : 1, 10 (min, max) The resulting knr Ratsrer layer contains pixels with their corresponding cluster labels. We will plor the clustering raster layer with the original raster image side by side in order to recognize the land cover classes for each cluster. # Use the ndvi object to set the cluster values to a new raster # Define a color vector for 10 clusters (learn more about setting the color later) mycolor &lt;- c(&quot;#fef65b&quot;,&quot;#ff0000&quot;, &quot;#daa520&quot;,&quot;#0000ff&quot;,&quot;#0000ff&quot;,&quot;#00ff00&quot;,&quot;#cbbeb5&quot;, &quot;#c3ff5b&quot;, &quot;#ff7373&quot;, &quot;#00ff00&quot;, &quot;#808080&quot;) par(mfrow = c(1,2)) plot(ndvi, col = rev(terrain.colors(10)), main = &#39;Landsat-NDVI&#39;) plot(knr, main = &#39;Unsupervised classification&#39;, col = mycolor ) "],
["supervised-classifcation.html", "Chapter 5 Supervised Classifcation 5.1 Reference data 5.2 Generate sample sites 5.3 Extract values for sites 5.4 Train the classifier 5.5 Classify 5.6 Model Evaluation", " Chapter 5 Supervised Classifcation In supervised classification, we have prior knowledge about some og the land-cover types. We need areas with identified land-cover types ti use them as training set to train the classification algotithm. In the following example we will use a Classification and Regresstion Trees (CART) classifier to predict land cover classes in the study area. We will perform the following steps: - Generate sample sites based on a reference raster - Extract alues from landsat data for the sample sites - Train the classifier using training samples - classify the landsat data using the trained model - Evaluate the accuracy of the model 5.1 Reference data The National Land Cover Databae 2011 (NLCD 2011) is a land cover product for the USA. NLCD is a 30-m Landsat-based land cover database. It is based on a decision tree classification of circa 2011 Landsat data. It has two pairs of class vales and names that correspond to the levels of land use and land cover classification system. First, we will load land cover data and prepare it for classification by attributing class names. library(raster) nlcd &lt;- brick(&#39;data/rs/nlcd-L1.tif&#39;) names(nlcd) &lt;- c(&quot;nlcd2001&quot;, &quot;nlcd2011&quot;) # The class names and colors for plotting nlcdclass &lt;- c(&quot;Water&quot;, &quot;Developed&quot;, &quot;Barren&quot;, &quot;Forest&quot;, &quot;Shrubland&quot;, &quot;Herbaceous&quot;, &quot;Planted/Cultivated&quot;, &quot;Wetlands&quot;) classdf &lt;- data.frame(classvalue1 = c(1,2,3,4,5,7,8,9), classnames1 = nlcdclass) # Hex codes of colors classcolor &lt;- c(&quot;#5475A8&quot;, &quot;#B50000&quot;, &quot;#D2CDC0&quot;, &quot;#38814E&quot;, &quot;#AF963C&quot;, &quot;#D1D182&quot;, &quot;#FBF65D&quot;, &quot;#C8E6F8&quot;) # Now we ratify (RAT = &quot;Raster Attribute Table&quot;) the ncld2011 (define RasterLayer as a categorical variable). This is helpful for plotting. nlcd2011 &lt;- nlcd[[2]] nlcd2011 &lt;- ratify(nlcd2011) rat &lt;- levels(nlcd2011)[[1]] # rat$landcover &lt;- nlcdclass levels(nlcd2011) &lt;- rat 5.2 Generate sample sites In this part We split the NLCD reference RatserLayer into training and validation sets.Before that we will spatial points of the site by ensuring equidistribution of land use classes by performing a stratified random sampling. # set the random number generator to reproduce the results set.seed(99) # Sampling samp2011 = sampleStratified(nlcd2011, size = 200, na.rm = TRUE, sp = TRUE) samp2011 ## class : SpatialPointsDataFrame ## features : 1600 ## extent : -121.9257, -121.4225, 37.85415, 38.18536 (xmin, xmax, ymin, ymax) ## crs : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## variables : 2 ## names : cell, nlcd2011 ## min values : 413, 1 ## max values : 2307837, 9 table(samp2011$nlcd2011) ## ## 1 2 3 4 5 7 8 9 ## 200 200 200 200 200 200 200 200 We can plot the sampled points to visualize the distribution of sampling locations. library(rasterVis) ## Loading required package: lattice ## Loading required package: latticeExtra plt &lt;- levelplot(nlcd2011, col.regions = classcolor, main = &#39;Distribution of Training Sites&#39;) print(plt + layer(sp.points(samp2011, pch = 3, cex = 0.5, col = 1))) 5.3 Extract values for sites We load the Landsat data landsat5 &lt;- stack(&#39;data/rs/centralvalley-2011LT5.tif&#39;) names(landsat5) &lt;- c(&#39;blue&#39;, &#39;green&#39;, &#39;red&#39;, &#39;NIR&#39;, &#39;SWIR1&#39;, &#39;SWIR2&#39;) We extract the raster values (for different band length of landsat data) corresponding to the sampled points with identified land cover classes. Then we create a dataframe containing the band values (which are our predictor variables) and the corresponding classes (which is our reponse variable) sampvals &lt;- extract(landsat5, samp2011, df = TRUE) # sampvals no longer has the spatial information. To keep the spatial information you use `sp=TRUE` argument in the `extract` function. # drop the ID column sampvals &lt;- sampvals[, -1] # combine the class information with extracted values sampdata &lt;- data.frame(classvalue = samp2011@data$nlcd2011, sampvals) 5.4 Train the classifier library(rpart) # Train the model cart &lt;- rpart(as.factor(classvalue)~., data=sampdata, method = &#39;class&#39;, minsplit = 5) # print(model.class) # Plot the trained classification tree plot(cart, uniform=TRUE, main=&quot;Classification Tree&quot;) text(cart, cex = 0.8) The classification tree plot shows the classvalues at the leaf nodes. 5.5 Classify Now we have a trained classification model that we can use to classify the cells in the landsat rasterstack. # Now predict the subset data based on the model; prediction for entire area takes longer time pr2011 &lt;- predict(landsat5, cart, type=&#39;class&#39;) pr2011 ## class : RasterLayer ## dimensions : 1230, 1877, 2308710 (nrow, ncol, ncell) ## resolution : 0.0002694946, 0.0002694946 (x, y) ## extent : -121.9258, -121.42, 37.85402, 38.1855 (xmin, xmax, ymin, ymax) ## crs : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## source : memory ## names : layer ## values : 1, 9 (min, max) ## attributes : ## ID value ## from: 1 1 ## to : 8 9 We can plot the classification results pr2011 &lt;- ratify(pr2011) rat &lt;- levels(pr2011)[[1]] rat$legend &lt;- classdf$classnames levels(pr2011) &lt;- rat levelplot(pr2011, maxpixels = 1e6, col.regions = classcolor, scales=list(draw=FALSE), main = &quot;Decision Tree classification of Landsat 5&quot;) We can plot side by side the real and predicted land cover in order to assess the classification model accuracy plot1 = levelplot(nlcd2011, maxpixels = 1e6, col.regions = classcolor, scales=list(draw=FALSE), main = &quot;Real land cover oof Landsat 5&quot;) plot2 = levelplot(pr2011, maxpixels = 1e6, col.regions = classcolor, scales=list(draw=FALSE), main = &quot;Decision Tree classification of Landsat 5&quot;) library(gridExtra) grid.arrange(plot1,plot2, ncol=2) 5.6 Model Evaluation Now we have to assess the accuracy of the model. Two metrics are widely used in remote sensing: “overall accuracy” and “kappa”. 5.6.1 K-fold cross validation We will use k-fold cross validation for the model evaluation. This technique consists on splitting the data to fit the model into k groups. In turn, one of the groups will be used for model testing, while the rest of the data is used for model training. library(dismo) set.seed(99) j &lt;- kfold(sampdata, k = 5, by=sampdata$classvalue) table(j) ## j ## 1 2 3 4 5 ## 320 320 320 320 320 Now we trainand test the model five times, each time computing a confusion matrix that we store in a list. x &lt;- list() for (k in 1:5) { train &lt;- sampdata[j!= k, ] test &lt;- sampdata[j == k, ] cart &lt;- rpart(as.factor(classvalue)~., data=train, method = &#39;class&#39;, minsplit = 5) pclass &lt;- predict(cart, test, type=&#39;class&#39;) # create a data.frame using the reference and prediction x[[k]] &lt;- cbind(test$classvalue, as.integer(pclass)) } Now we combine the five list elements in a single dataframe y &lt;- do.call(rbind, x) y &lt;- data.frame(y) colnames(y) &lt;- c(&#39;observed&#39;, &#39;predicted&#39;) conmat &lt;- table(y) # change the name of the classes colnames(conmat) &lt;- classdf$classnames rownames(conmat) &lt;- classdf$classnames conmat ## predicted ## observed Water Developed Barren Forest Shrubland Herbaceous ## Water 175 6 0 3 0 0 ## Developed 2 90 51 8 10 22 ## Barren 7 39 82 4 19 38 ## Forest 0 2 1 106 57 1 ## Shrubland 0 3 5 59 102 12 ## Herbaceous 0 9 36 10 27 109 ## Planted/Cultivated 0 7 11 34 42 19 ## Wetlands 18 10 6 36 29 5 ## predicted ## observed Planted/Cultivated Wetlands ## Water 7 9 ## Developed 11 6 ## Barren 5 6 ## Forest 6 27 ## Shrubland 12 7 ## Herbaceous 8 1 ## Planted/Cultivated 69 18 ## Wetlands 33 63 5.6.2 Overall accuracy # number of cases n &lt;- sum(conmat) n ## [1] 1600 # number of correctly classified cases per class diag &lt;- diag(conmat) # Overall Accuracy OA &lt;- sum(diag) / n OA ## [1] 0.4975 5.6.3 Kappa statistic # observed (true) cases per class rowsums &lt;- apply(conmat, 1, sum) p &lt;- rowsums / n # predicted cases per class colsums &lt;- apply(conmat, 2, sum) q &lt;- colsums / n expAccuracy &lt;- sum(p*q) kappa &lt;- (OA - expAccuracy) / (1 - expAccuracy) kappa ## [1] 0.4257143 5.6.4 Producer and user accuracy # Producer accuracy PA &lt;- diag / colsums # User accuracy UA &lt;- diag / rowsums outAcc &lt;- data.frame(producerAccuracy = PA, userAccuracy = UA) outAcc ## producerAccuracy userAccuracy ## Water 0.8663366 0.875 ## Developed 0.5421687 0.450 ## Barren 0.4270833 0.410 ## Forest 0.4076923 0.530 ## Shrubland 0.3566434 0.510 ## Herbaceous 0.5291262 0.545 ## Planted/Cultivated 0.4569536 0.345 ## Wetlands 0.4598540 0.315 "]
]
